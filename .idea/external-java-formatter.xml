<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ExternalJavaFormatterSettings">
    <option name="arguments" value="--width=120 {} " />
    <option name="testCode" value="package org.java8.stream;&#10;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.function.*;&#10;import java.util.stream.Collectors;&#10;import java.util.stream.Stream;&#10;&#10;class PredicateDemo implements Predicate&lt;Integer&gt; {&#10;    @Override&#10;    public boolean test(Integer integer) {&#10;        return false;&#10;    }&#10;}&#10;&#10;class BiPredicateDemo implements BiPredicate&lt;String, String&gt; {&#10;    @Override&#10;    public boolean test(String str1, String str2) {&#10;        return true;&#10;    }&#10;}&#10;&#10;class FunctionDemo implements Function&lt;String, String&gt; {&#10;    @Override&#10;    public String apply(String str) {&#10;        return str;&#10;    }&#10;}&#10;&#10;class BiFunctionDemo implements BiFunction&lt;Integer, Integer, Integer&gt; {&#10;    public Integer apply(Integer i2, Integer i3) {&#10;        return i2 + i3;&#10;    }&#10;}&#10;&#10;class ConsumerDemo implements Consumer&lt;Integer&gt; {&#10;    public void accept(Integer integer) {&#10;        for (int i = 0; i &lt;= integer; i++) {&#10;            try {&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException ie) {&#10;                ie.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class SupplierDemo implements Supplier&lt;Integer&gt; {&#10;    public Integer get() {&#10;        return 50;&#10;    }&#10;}&#10;&#10;class UnaryOperatorDemo implements UnaryOperator&lt;Integer&gt; {&#10;    @Override&#10;    public Integer apply(Integer integer) {&#10;        return integer;&#10;    }&#10;}&#10;&#10;class BinaryOperatorDemo implements BinaryOperator&lt;String&gt; {&#10;    @Override&#10;    public String apply(String string1, String string2) {&#10;        return string1 + string2;&#10;    }&#10;}&#10;&#10;public class StreamApi {&#10;&#10;    List&lt;StreamApi.Employee&gt; employeeList = new ArrayList&lt;StreamApi.Employee&gt;();&#10;    List&lt;Integer&gt; arrList = new ArrayList();&#10;&#10;    public static void main(String[] arg) {&#10;        StreamApi streamApi = new StreamApi();&#10;        streamApi.binaryOperator();&#10;        streamApi.unaryOperator();&#10;        streamApi.predicate();&#10;        streamApi.function();&#10;        streamApi.consumer();&#10;        streamApi.supplier();&#10;        streamApi.streamMethods();&#10;        streamApi.collectrosMethod();&#10;&#10;    }&#10;&#10;    public void binaryOperator() {&#10;        BinaryOperator&lt;String&gt; binaryOperatorAnonymousFunction = new BinaryOperator&lt;String&gt;() {&#10;            public String apply(String string1, String string2) {&#10;                return string1 + string2;&#10;            }&#10;        };&#10;        binaryOperatorAnonymousFunction.apply(&quot;Java &quot;, &quot;Programming&quot;);&#10;&#10;        BinaryOperator&lt;Integer&gt; binaryOperatorLambdaFunction = (Integer integer1, Integer integer2) -&gt; {&#10;            return integer1 + integer2;&#10;        };&#10;        Integer integerValue = binaryOperatorLambdaFunction.apply(10, 30);&#10;        System.out.println(integerValue);&#10;    }&#10;&#10;    public void unaryOperator() {&#10;        UnaryOperator&lt;String&gt; unaryOperatorAnonymousFunction = new UnaryOperator&lt;String&gt;() {&#10;            public String apply(String str) {&#10;                return str;&#10;            }&#10;        };&#10;        String getString = unaryOperatorAnonymousFunction.apply(&quot;java8&quot;);&#10;        System.out.println(getString);&#10;&#10;        UnaryOperator&lt;Integer&gt; unaryOperatorLambdaFunction = (Integer integer) -&gt; {&#10;            return integer;&#10;        };&#10;        Integer getInteger = unaryOperatorLambdaFunction.apply(20);&#10;        System.out.println(getInteger);&#10;    }&#10;&#10;    public void predicate() {&#10;        Predicate&lt;Integer&gt; predicateAnonymousFunction = new Predicate&lt;Integer&gt;() {&#10;            public boolean test(Integer integer) {&#10;                return false;&#10;            }&#10;        };&#10;        predicateAnonymousFunction.test(259);&#10;&#10;        Predicate&lt;Integer&gt; predicateLambdaFunction = (Integer integer) -&gt; {&#10;            return false;&#10;        };&#10;        predicateLambdaFunction.test(10);&#10;    }&#10;&#10;    public void function() {&#10;        Function&lt;Integer, Integer&gt; functionAnonymous = new Function&lt;Integer, Integer&gt;() {&#10;            public Integer apply(Integer integer) {&#10;                return integer;&#10;            }&#10;        };&#10;&#10;        Function&lt;Integer, Integer&gt; functionLambda = (Integer integer) -&gt; {&#10;            return integer;&#10;        };&#10;        functionLambda.apply(500);&#10;&#10;        BiFunction&lt;Integer, Integer, String&gt; biFunctionAnonymousFunction = new BiFunction&lt;Integer, Integer, String&gt;() {&#10;            public String apply(Integer integer3, Integer integer4) {&#10;                return integer3 + integer4 + &quot;&quot;;&#10;            }&#10;        };&#10;    }&#10;&#10;    public void consumer() {&#10;        Consumer&lt;Integer&gt; consumerAnonymousFunction = new Consumer&lt;Integer&gt;() {&#10;            @Override&#10;            public void accept(Integer integer) {&#10;                for (int i = 0; i &lt;= integer; i++) {&#10;                    try {&#10;                        Thread.sleep(1000);&#10;                        System.out.println(i);&#10;                    } catch (InterruptedException ie) {&#10;                        ie.printStackTrace();&#10;                    }&#10;                }&#10;            }&#10;        };&#10;        consumerAnonymousFunction.accept(2);&#10;&#10;        Consumer&lt;Integer&gt; consumerLambdaFunction = (Integer integer) -&gt; {&#10;            for (int i = 0; i &lt;= integer; i++) {&#10;                try {&#10;                    Thread.sleep(1000);&#10;                    System.out.println(i);&#10;                } catch (InterruptedException ie) {&#10;                    ie.printStackTrace();&#10;                }&#10;            }&#10;        };&#10;        consumerLambdaFunction.accept(2);&#10;    }&#10;&#10;    public void supplier() {&#10;        Supplier&lt;StringBuilder&gt; supplierAnonymousFunction = new Supplier&lt;StringBuilder&gt;() {&#10;            @Override&#10;            public StringBuilder get() {&#10;                return new StringBuilder();&#10;            }&#10;        };&#10;        StringBuilder stringBuilder = supplierAnonymousFunction.get();&#10;        stringBuilder.append(&quot;java is programming language&quot;);&#10;        System.out.println(stringBuilder);&#10;&#10;        Supplier&lt;StringBuffer&gt; supplierLambdaFunction = () -&gt; {&#10;            return new StringBuffer();&#10;        };&#10;        StringBuffer stringBuffer = supplierLambdaFunction.get();&#10;    }&#10;&#10;    public void streamMethods() {&#10;        Employee emp1 = new Employee(&quot;java&quot;, &quot;java Programming&quot;, 22, 123456789);&#10;        Employee emp2 = new Employee(&quot;javaScript&quot;, &quot;javaScript Programming&quot;, 01, 010101010101);&#10;        Employee emp3 = new Employee(&quot;Phython&quot;, &quot;Phython Programming&quot;, 0365, 55555555555555L);&#10;        Employee emp4 = new Employee(&quot;Html&quot;, &quot;Html Programming&quot;, 22, 125468896545L);&#10;        List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;();&#10;        employeeList.add(emp1);&#10;        employeeList.add(emp2);&#10;        employeeList.add(emp3);&#10;        employeeList.add(emp4);&#10;&#10;        List&lt;Integer&gt; arrList = new ArrayList&lt;Integer&gt;();&#10;        arrList.add(10);&#10;        arrList.add(20);&#10;        arrList.add(50);&#10;        arrList.add(40);&#10;        arrList.add(20);&#10;        arrList.add(10);&#10;&#10;        double getDoubleValue = arrList.stream().collect(Collectors.averagingInt(element -&gt; {&#10;            return element.intValue();&#10;        }));&#10;        System.out.println(getDoubleValue);&#10;&#10;        List&lt;Integer&gt; collectingAndThen = arrList.stream().collect(Collectors.collectingAndThen(Collectors.toList(), (element) -&gt; {&#10;            return Collections.unmodifiableList(element);&#10;        }));&#10;        System.out.println(collectingAndThen);&#10;&#10;        long counting = arrList.stream().collect(Collectors.counting());&#10;        System.out.println(counting);&#10;        Map&lt;Integer, List&lt;Integer&gt;&gt; map = arrList.stream().collect(Collectors.groupingBy((Integer ele) -&gt; {&#10;            return ele;&#10;        }));&#10;&#10;        Map&lt;String, Set&lt;Employee&gt;&gt; employeeMap = employeeList.stream().collect(Collectors.groupingBy(groupElement -&gt; {&#10;            return groupElement.empName;&#10;        }, Collectors.toSet()));&#10;        System.out.println(employeeMap);&#10;á¸&#10;        Map&lt;Integer, List&lt;Employee&gt;&gt; employeeMap2 = employeeList.stream().collect(Collectors.groupingBy(groupElement -&gt; groupElement.empId));&#10;&#10;        Random random = new Random();&#10;        Stream.generate(random::nextInt).limit(4).forEach(System.out::println);&#10;        this.employeeList.stream().forEachOrdered(element -&gt; {&#10;            System.out.println(element);&#10;        });&#10;&#10;        System.out.println(&quot;-----------------------------------------------------------------------------&quot;);&#10;&#10;        this.employeeList.stream().forEach(item -&gt; {&#10;            System.out.println(item);&#10;        });&#10;        List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;();&#10;        linkedList.add(10);&#10;        linkedList.add(50);&#10;        linkedList.add(20);&#10;        linkedList.add(30);&#10;        List&lt;Integer&gt; mappedData = linkedList.stream().peek(System.out::println).map(element -&gt; element * 2).collect(Collectors.toList());&#10;        System.out.println(linkedList);&#10;        List&lt;Integer&gt; sorted = linkedList.stream().sorted().collect(Collectors.toList());&#10;        System.out.println(sorted);&#10;    }&#10;&#10;    public void collectrosMethod() {&#10;        StreamApi.Employee emp1 = new StreamApi().new Employee(&quot;java&quot;, &quot;mumbai&quot;, 15, 2222222222L);&#10;        StreamApi.Employee emp2 = new StreamApi().new Employee(&quot;phython&quot;, &quot;pune&quot;, 25, 123456789L);&#10;        StreamApi.Employee emp3 = new StreamApi().new Employee(&quot;javaScript&quot;, &quot;Latur&quot;, 35, 3333333333L);&#10;        StreamApi.Employee emp4 = new StreamApi().new Employee(&quot;Hari Om&quot;, &quot;Banner&quot;, 2566541, 78945612300L);&#10;        employeeList.add(emp1);&#10;        employeeList.add(emp2);&#10;        employeeList.add(emp3);&#10;        employeeList.add(emp4);&#10;&#10;        Map&lt;Integer, List&lt;StreamApi.Employee&gt;&gt; map = employeeList.stream().collect(Collectors.groupingBy((item) -&gt; {&#10;            return item.empId;&#10;        }, () -&gt; {&#10;            return new HashMap&lt;Integer, List&lt;StreamApi.Employee&gt;&gt;();&#10;        }, Collectors.toList()));&#10;        System.out.println(map);&#10;&#10;        Map&lt;String, List&lt;StreamApi.Employee&gt;&gt; groupingByConcurrent = employeeList.stream().collect(Collectors.groupingByConcurrent((StreamApi.Employee element) -&gt; {&#10;            return element.empAddress;&#10;        }, () -&gt; {&#10;            return new ConcurrentHashMap&lt;&gt;();&#10;        }, Collectors.toList()));&#10;        System.out.println(groupingByConcurrent);&#10;&#10;        String joining = employeeList.stream().map(element -&gt; {&#10;            return element.empName;&#10;        }).collect(Collectors.joining(&quot;&quot;));&#10;        System.out.println(joining);&#10;&#10;        Map&lt;Integer, List&lt;Integer&gt;&gt; mapping = employeeList.stream().collect(Collectors.groupingBy(element -&gt; element.empId, Collectors.mapping(maping -&gt; maping.empId, Collectors.toList())));&#10;&#10;        List&lt;String&gt; mappingTheElement = employeeList.stream().collect(Collectors.mapping(element -&gt; element.empAddress, Collectors.toList()));&#10;        System.out.println(mappingTheElement);&#10;&#10;        List&lt;Integer&gt; mappingWithInteger = employeeList.stream().collect(Collectors.mapping(element -&gt; element.empId, Collectors.toList()));&#10;        System.out.println(mappingWithInteger);&#10;        //&#10;        Map&lt;Integer, List&lt;StreamApi.Employee&gt;&gt; mapElement = employeeList.stream().collect(Collectors.toMap(element -&gt; element.empId, element2 -&gt; {&#10;            return Collections.singletonList(element2);&#10;            // List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();&#10;            // list.add(element2);&#10;            // return list;&#10;        }));&#10;        System.out.println(mapElement);&#10;&#10;        List&lt;Integer&gt; mapElement2 = employeeList.stream().collect(Collectors.mapping(mapped -&gt; mapped.empId, Collectors.toList()));&#10;&#10;        Optional&lt;Integer&gt; optional = mapElement2.stream().collect(Collectors.minBy((min1, min2) -&gt; {&#10;            return min1.compareTo(min2);&#10;        }));&#10;        System.out.println(optional);&#10;&#10;        Map&lt;Boolean, List&lt;Integer&gt;&gt; partitioningBy = employeeList.stream().collect(Collectors.partitioningBy((element) -&gt; {&#10;            return element.empId &gt;= 100;&#10;        }, Collectors.mapping(element -&gt; element.empId, Collectors.toList())));&#10;        System.out.println(partitioningBy);&#10;&#10;        Map&lt;Boolean, Map&lt;Integer, StreamApi.Employee&gt;&gt; partitioningByMap = employeeList.stream().collect(Collectors.partitioningBy(predicate -&gt; predicate.empId &lt;= 100, Collectors.toMap(key -&gt; key.empId, value -&gt; value)));&#10;        System.out.println(partitioningByMap);&#10;&#10;        arrList.add(20);&#10;        arrList.add(30);&#10;        arrList.add(40);&#10;        arrList.add(55);&#10;        Optional&lt;Integer&gt; optional23 = arrList.stream().collect(Collectors.reducing((ele, ele2) -&gt; {&#10;            return ele + ele2;&#10;        }));&#10;        System.out.println(optional23);&#10;&#10;        Optional&lt;StreamApi.Employee&gt; optional12 = employeeList.stream().collect(Collectors.reducing(new BinaryOperator&lt;StreamApi.Employee&gt;() {&#10;            public StreamApi.Employee apply(StreamApi.Employee a, StreamApi.Employee b) {&#10;                return a;&#10;            }&#10;        }));&#10;        System.out.println(optional12);&#10;&#10;        Optional&lt;StreamApi.Employee&gt; optional123 = employeeList.stream().collect(Collectors.reducing((StreamApi.Employee emp, StreamApi.Employee emp12) -&gt; {&#10;            return emp;&#10;        }));&#10;&#10;        Optional&lt;Integer&gt; returnOptional = arrList.stream().collect(Collectors.reducing((reduce1, reduce2) -&gt; {&#10;            return reduce1 - reduce2;&#10;        }));&#10;        System.out.println(returnOptional);&#10;&#10;        // summarizingLong&#10;        LongSummaryStatistics summrizingToLong = arrList.stream().collect(Collectors.summarizingLong((Integer integer) -&gt; {&#10;            return integer;&#10;        }));&#10;        System.out.println(summrizingToLong);&#10;&#10;    }&#10;&#10;    class Employee {&#10;        String empName;&#10;        String empAddress;&#10;        int empId;&#10;        long empContactNumber;&#10;&#10;        public Employee(String empName, String empAddress, int empId, long empContactNumber) {&#10;            this.empName = empName;&#10;            this.empAddress = empAddress;&#10;            this.empId = empId;&#10;            this.empContactNumber = empContactNumber;&#10;        }&#10;&#10;        public String toString() {&#10;            return &quot;{&quot; + empName + &quot;,&quot; + empAddress + &quot;,&quot; + empId + &quot;,&quot; + empContactNumber + &quot;}&quot;;&#10;        }&#10;    }&#10;}" />
  </component>
</project>